

# This file was *autogenerated* from the file solver.sage
from sage.all_cmdline import *   # import sage library

_sage_const_3 = Integer(3); _sage_const_59 = Integer(59); _sage_const_10 = Integer(10); _sage_const_25 = Integer(25); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_256 = Integer(256); _sage_const_2 = Integer(2)# Jiahui Chen et al. cryptosystem, 80-bit security
# WARNING: very slow implementation.
import sys
import re

q, n, a, s = (_sage_const_3 , _sage_const_59 , _sage_const_10 , _sage_const_25 )
m = n+_sage_const_1 -a+s
FF = GF(q)
R = PolynomialRing(FF, ["x{}".format(i) for i in range(n)])
xs = R.gens()


def combine_blocks(blocks):
    x = _sage_const_0 
    for i in blocks[::-_sage_const_1 ]:
        for j in i[::-_sage_const_1 ]:
            x = x*q+Integer(j)
    ss = ""
    while x > _sage_const_0 :
        ss = chr(x % _sage_const_256 ) + ss
        x = x//_sage_const_256 
    return ss


with open("output") as f:
    pk = sage_eval(re.sub(r'x(\d+)', r'xs[\1]', f.readline()), locals={'xs': xs})
    ciphertext = eval(f.readline())
    ciphertext = tuple(map(lambda v: vector(FF, v), ciphertext))

# the attack is based on: https://eprint.iacr.org/2020/053.pdf
step_1_matrix = [[_sage_const_0  for _ in range(n * (n+_sage_const_1 ) // _sage_const_2 )] for _ in range(m)]

for i in range(m):
    pki = pk[i]
    cc = _sage_const_0 
    # collect quadratic terms
    for (coeff, exp) in zip(pki.coefficients(), pki.exponents()):
        exp = list(exp)
        idx = []
        for exp_idx in range(n):
            while exp[exp_idx] > _sage_const_0 :
                exp[exp_idx] = exp[exp_idx] - _sage_const_1 
                idx.append(exp_idx)
        if len(idx) == _sage_const_2 :
            term_idx = idx[_sage_const_1 ] * (idx[_sage_const_1 ] + _sage_const_1 ) // _sage_const_2  + idx[_sage_const_0 ]
            step_1_matrix[i][term_idx] = coeff

# find the kernel
step_1_matrix = matrix(FF, step_1_matrix)
kernel_basis = step_1_matrix.kernel().basis()

# should be 49-dimensional
assert len(kernel_basis) == n-a

# generate n-a linearly independent degree-one polynomials
rs = []
ds_start = []
for y in range(n-a):
    rr = _sage_const_0 
    dd = _sage_const_0 
    for x in range(m):
        rr = rr + kernel_basis[y][x] * pk[x]

    # degree-one polynomial to matrix
    rrv = [_sage_const_0  for _ in range(n)]
    for (coeff, exp) in zip(rr.coefficients(), rr.exponents()):
        try:
            rrv[tuple(exp).index(_sage_const_1 )] = coeff
        except ValueError:
            dd -= coeff

    rs.append(rrv)
    ds_start.append(dd)

rs = matrix(FF, rs)

answer_blocks = []

# solve the systems of linear equation
for (block_idx, block) in enumerate(ciphertext):
    ds = []
    for y in range(n-a):
        dd = ds_start[y]
        for x in range(m):
            dd = dd + kernel_basis[y][x] * block[x]
        ds.append(dd)

    # find a base solution and kernel basis
    ds = vector(ds)
    sol_basis = rs.transpose().kernel().basis()
    x_pre = rs.solve_right(ds)

    assert rs * x_pre == ds
    assert len(sol_basis) == a

    for i in range(q ** a):
        remain = i
        x = copy(x_pre)
        for base_idx in range(a):
            x += (remain % q) * sol_basis[base_idx]
            remain = remain // q

        if i % (_sage_const_3  ** _sage_const_3 ) == _sage_const_0 :
            print(f"block {block_idx}, try {i}/{q ** a}")

        incorrect = False
        for m_idx in range(m):
            if not pk[m_idx](*x) == block[m_idx]:
                incorrect = True
                break

        if not incorrect:
            answer_blocks.append(x)
            break

print(combine_blocks(answer_blocks))

